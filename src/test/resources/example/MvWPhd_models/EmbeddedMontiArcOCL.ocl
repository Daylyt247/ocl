import EmbeddedMontiArc.*;

// slide Ch04_PortValue

context NaturalNumber inv:
  value >= 1 &&
  !isPlusInf && !isMinusInf

context Matrix inv:
  depth ==1

context Vector inv:
  rows == 1

context Number inv:
  cols == 1;

// Ch04_PortTypeSystem
context StructItem inv:
  this.name == type.name

// Ch04_Parameter3
context ComponentParameter inv:
  type instanceof ComponentInterface

context Component inv:
  forall t in implements.type:
    (t instanceof ComponentInterface)

// TODO: this is incomplete: handle cases when t1.res or t2.res are absent
context NumericType t1, NumericType t2 inv:
  let
     maxSteps1 = {1 .. 2*Math.abs(t1.max.value / t1.res.value) + 1};
     range1 = { v | v = t1.min.value + k * t1.res.value, k in maxSteps1, v <= t1.max.value };
     maxSteps2 = {1 .. 2*Math.abs(t2.max.value / t2.res.value) + 1};
     range2 = { v | v = t2.min.value + k * t2.res.value, k in maxSteps2, v <= t2.max.value };
  in
    (t1 <= t2) <=>
    (t1.quantity == t2.quantity &&
    t1.cols == t2.cols &&
    t1.rows == t2.rows &&
    range2.containsAll(range1) &&
    t2.algebraicProperties.containsAll(t1.algebraicProperties))

context Connector inv:
  sourcePort.port.type <= targetPort.port.type

context PortInstantiation inv:
  portIndices.end <= port.dimension &&
  subIndices.end <= sub.dimension

context Range inv:
  start <= end

// Ch04_Effector

context Effector inv:
  sourceIndex.end <= sourcePort.dimension &&
  targetIndex.end <= sourcePort.dimension

context Effector inv:
  let
    sct = sourcePort.componentType;
    s = typeif sct instanceof Component then sct.subs else {};
  in
    sourcePort.direction == PortDirection.IN  &&
    targetPort.direction == PortDirection.OUT  &&
    sct == targetPort.componentType &&
    s == {}


// Ch04_Component

context Component inv:
  forall cmpType in implements.type:
    cmpType.ports.name == this.ports.name

context Component inv:
  let
    typeDimParams = {p in ports.type.addAll(ports.dimension) |
                     p instanceof Parameter};
  in
    this.subs != {} implies
    this.parameters ==
    subs.values.parameter
      .addAll(typeDimParams)
      .addAll( { param | param in this.parameters,
                        exists param2 in this.parameters:
                               param == param2.type})

// Ch04_CnCModel

context CnCModel inv:
  let
    inPorts = {p | p in components.ports, p.direction == PortDirection.IN};
  in
    forall p in inPorts:
      forall pi in PortInstantiation:
        (pi.port == p && pi.sub != main) implies
        (exists con in connectors:
           pi == con.targetPort)

// Ch04_CnCInstanceStructure

context ComponentInst inv:
  (forall p in params.parameter:
    p.kind == ParameterKind.CONFIG) &&
 (subs != {} implies params == {})

context PortInst inv:
  ! (type instanceof Parameter)


// Ch04_InstanceChain

context ComponentInst inv:
  sender == { p.sender |
     p in this.ports}.componentInst &&
  receiver == { p.receiver |
     p in this.ports}.componentInst

context PortInst inv:
  sender.asSet == { PortInst p | exists con in ConnectorInst:
                          con.sourcePort == p && con.targetPort == this } &&
  receiver == {PortInst p | exists con in ConnectorInst:
                          con.sourcePort == this && con.targetPort == p} &&
  influencer == sender.asSet.addAll( {p | exists eff in EffectorInst:
                          eff.sourcePort == p && eff.targetPort == this} )   &&
  influencee == receiver.addAll( {p | exists eff in EffectorInst:
                          eff.sourcePort == this && eff.targetPort == p} )

// Ch06_CO1

context ConnectorInst inv CO1:
  let
     srcCI = sourcePort.componentInst;
     tgtCI = targetPort.componentInst;
     srcD = sourcePort.direction;
     tgtD = targetPort.direction;
  in
    (srcCI == tgtCI && srcD != tgtD)   || // in -> out, out -> in (loop)
    (tgtCI.parent == srcCI && srcD == PortDirection.IN && tgtD == PortDirection.OUT) || // in -> sub.in
    (srcCI.parent == tgtCI.parent && tgtCI != srcCI &&
                   srcD == PortDirection.OUT && tgtD == PortDirection.IN) || // sub1.in -> sub2.in
    (srcCI.parent == tgtCI && srcD == PortDirection.OUT && tgtD == PortDirection.OUT) // sub.out -> out

// Ch06_R1R2

context ConnectorInst conInst1, conInst2 inv R1R2:
  conInst1.targetPort == conInst2.targetPort implies
    conInst1.sourcePort == conInst2.sourcePort

// Ch06_R13

context Component inv:
  subDefs == {t | s in subs, t = s.type, t instanceof Component}

context Component inv R13:
  !(this isin subDefs**)

// Ch06_B1

context Component inv:
  innerElements ==
    ports.addAll(parameters).addAll(subs).addAll(innerComponents)

context Component inv B1:
  forall e1, e2 in innerElements:
    e1.name == e2.name implies e1 == e2

// Ch06_CV5CV6

context Component cmp inv CV5:
  cmp.subs != {} || (exists ComponentInstantiation ci: ci.parent == cmp) implies
    forall p in cmp.ports:
      exists con in Connector:
        (p == con.sourcePort.port || p == con.targetPort.port)

context Component cmp inv CV6:
  forall ci in {ComponentInstantiation ci | ci.type == cmp}, p in cmp.ports:
    exists con in Connector:
      (p == con.sourcePort.port && ci == con.sourcePort.sub ||
       p == con.targetPort.port && ci == con.targetPort.sub)

// Ch06_R9R10

context ComponentInstantiation inv R9R10:
  forall p in type.parameters:
    !(exists p2 in type.parameters: // p can be inferred due to bounded
        p2.kind == ParameterKind.CONFIG &&        // configuration parameter p2
        (p2.dimension == p || p2.type.rows == p || p2.type.cols == p)
    ) &&
    (p.value.isAbsent implies
      exists pb in values:
        pb.parameter == p)
