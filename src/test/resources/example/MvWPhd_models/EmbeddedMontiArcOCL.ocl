import EmbeddedMontiArc.*;

// slide Ch04_PortValue

context NaturalNumber inv:
  value >= 1 &&
  !isPlusInf && !isMinusInf

context Matrix inv:
  depth ==1

context Vector inv:
  rows == 1

context Number inv:
  cols == 1;

// Ch04_PortTypeSystem
context StructItem inv:
  this.name == type.name

// Ch04_Parameter3
context ComponentParameter inv:
  type instanceof ComponentInterface

context Component inv:
  forall t in implements.type:
    (t instanceof ComponentInterface)

// TODO: this is incomplete: handle cases when t1.res or t2.res are absent
context NumericType t1, NumericType t2 inv:
  let
     maxSteps1 = {1 .. 2*Math.abs(t1.max.value / t1.res.value) + 1};
     range1 = { v | v = t1.min.value + k * t1.res.value, k in maxSteps1, v <= t1.max.value };
     maxSteps2 = {1 .. 2*Math.abs(t2.max.value / t2.res.value) + 1};
     range2 = { v | v = t2.min.value + k * t2.res.value, k in maxSteps2, v <= t2.max.value };
  in
    (t1 <= t2) <=>
    (t1.quantity == t2.quantity &&
    t1.cols == t2.cols &&
    t1.rows == t2.rows &&
    range2.containsAll(range1) &&
    t2.algebraicProperties.containsAll(t1.algebraicProperties))

context Connector inv:
  sourcePort.port.type <= targetPort.port.type

context PortInstantiation inv:
  portIndices.end <= port.dimension &&
  subIndices.end <= sub.dimension

context Range inv:
  start <= end

// Ch04_Effector

context Effector inv:
  sourceIndex.end <= sourcePort.dimension &&
  targetIndex.end <= sourcePort.dimension

context Effector inv:
  let
    sct = sourcePort.componentType;
    s = typeif sct instanceof Component then sct.subs else {};
  in
    sourcePort.direction == PortDirection.IN  &&
    targetPort.direction == PortDirection.OUT  &&
    sct == targetPort.componentType &&
    s == {}


// Ch04_Component

context Component inv:
  forall cmpType in implements.type:
    cmpType.ports.name == this.ports.name

context Component inv:
  let
    typeDimParams = {p in ports.type.addAll(ports.dimension) |
                     p instanceof Parameter};
  in
    this.subs != {} implies
    this.parameters ==
    subs.values.parameter
      .addAll(typeDimParams)
      .addAll( { param | param in this.parameters,
                        exists param2 in this.parameters:
                               param == param2.type})

// Ch04_CnCModel

context CnCModel inv:
  let
    inPorts = {p | p in components.ports, p.direction == PortDirection.IN};
  in
    forall p in inPorts:
      forall pi in PortInstantiation:
        (pi.port == p && pi.sub != main) implies
        (exists con in connectors:
           pi == con.targetPort)

// Ch04_CnCInstanceStructure

context ComponentInst inv:
  (forall p in params.parameter:
    p.kind == ParameterKind.CONFIG) &&
 (subs != {} implies params == {})

context PortInst inv:
  ! (type instanceof Parameter)


// Ch04_InstanceChain

context ComponentInst inv:
  sender == { p.sender |
     p in this.ports}.componentInst &&
  receiver == { p.receiver |
     p in this.ports}.componentInst

context PortInst inv:
  sender.asSet == { PortInst p | exists con in ConnectorInst:
                          con.sourcePort == p && con.targetPort == this } &&
  receiver == {PortInst p | exists con in ConnectorInst:
                          con.sourcePort == this && con.targetPort == p} &&
  influencer == sender.asSet.addAll( {p | exists eff in EffectorInst:
                          eff.sourcePort == p && eff.targetPort == this} )   &&
  influencee == receiver.addAll( {p | exists eff in EffectorInst:
                          eff.sourcePort == this && eff.targetPort == p} )

// Ch06_CO1

context ConnectorInst inv CO1:
  let
     srcCI = sourcePort.componentInst;
     tgtCI = targetPort.componentInst;
     srcD = sourcePort.direction;
     tgtD = targetPort.direction;
  in
    (srcCI == tgtCI && srcD != tgtD)   || // in -> out, out -> in (loop)
    (tgtCI.parent == srcCI && srcD == PortDirection.IN && tgtD == PortDirection.OUT) || // in -> sub.in
    (srcCI.parent == tgtCI.parent && tgtCI != srcCI &&
                   srcD == PortDirection.OUT && tgtD == PortDirection.IN) || // sub1.in -> sub2.in
    (srcCI.parent == tgtCI && srcD == PortDirection.OUT && tgtD == PortDirection.OUT) // sub.out -> out

// Ch06_R1R2

context ConnectorInst conInst1, conInst2 inv R1R2:
  conInst1.targetPort == conInst2.targetPort implies
    conInst1.sourcePort == conInst2.sourcePort

// Ch06_R13

context Component inv:
  subDefs == {t | s in subs, t = s.type, t instanceof Component}

context Component inv R13:
  !(this isin subDefs**)

// Ch06_B1

context Component inv:
  innerElements ==
    ports.addAll(parameters).addAll(subs).addAll(innerComponents)

context Component inv B1:
  forall e1, e2 in innerElements:
    e1.name == e2.name implies e1 == e2

// Ch06_CV5CV6

context Component cmp inv CV5:
  cmp.subs != {} || (exists ComponentInstantiation ci: ci.parent == cmp) implies
    forall p in cmp.ports:
      exists con in Connector:
        (p == con.sourcePort.port || p == con.targetPort.port)

context Component cmp inv CV6:
  forall ci in {ComponentInstantiation ci | ci.type == cmp}, p in cmp.ports:
    exists con in Connector:
      (p == con.sourcePort.port && ci == con.sourcePort.sub ||
       p == con.targetPort.port && ci == con.targetPort.sub)

// Ch06_R9R10

context ComponentInstantiation inv R9R10:
  forall p in type.parameters:
    !(exists p2 in type.parameters: // p can be inferred due to bounded
        p2.kind == ParameterKind.CONFIG &&        // configuration parameter p2
        (p2.dimension == p || p2.type.rows == p || p2.type.cols == p)
    ) &&
    (p.value.isAbsent implies
      exists pb in values:
        pb.parameter == p)

/////////////////////////////////////////////////////////////////////////
///// Constraints about Extra-functional properties
/////////////////////////////////////////////////////////////////////////

// Ch06_Traceability

context ComponentInst inv Traceability:
  let
    selection = this;
    aggregation = component.traceable;
    compareTo   = traceable;
  in         // comparison
    aggregation implies compareTo

// Ch06_CombinedPower

context ComponentInst inv MaxPower:
  let
    selection = component;
    aggregation =
      max maxPower ?: 0 W;
    compareTo =
      min selection.maxPower ?: oo W;
  in         // comparison
    aggregation <= compareTo

// Ch06_EncryptionTargetPort

context Port inv Encryption:
  let  // selection is a set of sender ports
    selection = portInstantiations
              .endCon.sourcePort.port;
    aggregation = { p.encryption.elements
                       | p in selection };
    compareTo = encryption.elements;
  in         // comparison
    forall encSrc in aggregation:
      encSrc.retainAll(compareTo) != {}

// Ch06_CombinedPowerX

context ComponentInst inv PowerConsumptionWithEncryption:
  let  // selections are subcomponent and port instances
    selection1 = subs;
    selection2 = ports.addAll(subs.ports);
    aggregation = sum List{ max s.maxPower ?: 0W | s in selection1 }
                + sum List{ max pi.encryption.encryptPower ?: 0W |
                        pi in selection2, pi.receiver != {} }
                + sum List{ max pi.encryption.decryptPower ?: 0W |
                        pi in selection2, pi.sender.isPresent };
    compareTo = min component.maxPower ?: oo W;
  in
    aggregation <= compareTo

// Ch06_CombinedPowerWithTable
context ComponentInst inv PowerConsumptionWithEncryption:
  let selection1 = subs;
      selection2 = ports.addAll(subs.ports);
      ep = component.encryptPower;
      aggregation = sum List{ max s.maxPower ?: 0W | s in selection1 }
                  + sum List{ max ep[pi.encryption].encrypt ?: 0W |
                              pi in selection2, pi.receiver != {} }
                  + sum List{ max ep[pi.encryption].decrypt ?: 0W |
                              pi in selection2, pi.sender.isPresent };
      compareTo = min component.maxPower ?: oo W;
  in
    aggregation <= compareTo

// Ch06_ASIL
context ComponentInst inv ASIL:
  let
    asilNb = List{ EAsil.QM, EAsil.ASIL_A, EAsil.ASIL_B,
                   EAsil.ASIL_C, EAsil.ASIL_D };
    selection = subs;
    aggregation = min {
      min asilNb.indexOf(s.asil.value) ?: 0 |
      s in selection.component           };
    compareTo = min asilNb.indexOf(
                   component.asil.value) ?: 0;
  in         // comparison
    aggregation >= compareTo

// Ch06_WCET_SingleCore
context NumberDuration inv MinTag:
  this >= 0s

context ComponentInst inv WCET_SingleCore:
  let
    selection = subs;
    aggregation = sum { max s.wcet ?: 0s |
                  s in selection.component };
    compareTo = min component.wcet ?: oo s;
  in         // comparison
    aggregation <= compareTo

context ComponentInst inv WCET_InfiteCores:
  let
    startSubs = {s in subs | this in s.sender };
    outPorts = {p in ports | p.direction == PortDirection.OUT};
    // selection: chains from subcomponents to
    // an output port
    selection = { chain in startSubs.start |
                  chain.end in outPorts };
    subChains = { chain.retainAll(subs) |
                  chain in selection };
    aggChains = { sum List{ max s.wcet ?: 0s |
                        s in chain.elements.component } |
                  chain in subChains };
    aggregation = max aggChains ?: 0s;
    compareTo = min component.wcet ?: oo s;
  in
    aggregation <= compareTo

context ComponentInst inv WCET_MultiCore:
let
  startSubs = {s in subs | this in s.sender };
  outPorts = {p in ports | p.direction == PortDirection.OUT};
  // selection: chains from subcomponents to
  // an output port
  selection = { chain in startSubs.start | chain.end in outPorts };
  subChains = { chain.retainAll(subs) | chain in selection };
  threads = min cis.main.threads ?: 1;

  // calculates all partition combinations

  combChains=subChains.listPartitions(threads);

  combSubs = { { {chain | chain in partition}.flatten.asSet |
               partition in singleComb } |
             singleComb in combChains };

  partSums =  { { { sum List{ max s.wcet ?: 0s |
                            s in el.elements.component}|
                  el in partition } |
                partition in singleCombs } |
              singleCombs in combSubs };

  maxTimeInComb = { max { sc | sc in singleComb }.flatten ?: 0s
    | singleComb in partSums };
  // aggregation takes best combination
  aggregation = min maxTimeInComb ?: 0s;
  compareTo = min component.wcet ?: oo s;
in
  aggregation <= compareTo

// Ch06_Traceability2
context Component inv Traceability2:
  let
    selection = componentInsts;
    aggregation =
      and componentInsts.traceable;
    compareTo   = traceable;
  in         // comparison
    compareTo implies aggregation

/////////////////////////////////////////////////////////////////////////
///// Constraints about relation between EmbeddedMontiArc sugar and EmbeddedMontiArc normalized
/////////////////////////////////////////////////////////////////////////

// Ch06_OCLTrafo1

context Range rn, RangeSugar rs inv:
 let pi = rs.portInstantiation;
   dimension = pi.portIndices == rs ? (pi.port.dimension ?: 1) :
                                      (pi.sub.dimension ?: 1) ;
 in
   rn ~~ rs <=>
   (rs.all implies rn.start == 1 && rn.step == 1 && rn.end == dimension) &&
   (!rs.all implies rn.start == rs.start && rn.end == rs.end   &&
                                                   rn.step == rs.step ?: 1)
