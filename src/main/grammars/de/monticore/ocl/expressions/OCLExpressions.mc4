/* (c) https://github.com/MontiCore/monticore */
package de.monticore.ocl.expressions;

/* Alpha-version: This is intended to become a MontiCore stable grammar. */

import de.monticore.expressions.*;
import de.monticore.types.*;
import de.monticore.statements.*;
import de.monticore.symbols.*;

/**
 * This grammar defines a expressions typical to UMLs OCL
 */
component grammar OCLExpressions
          extends ExpressionsBasis,
                  MCBasicTypes,
                  MCVarDeclarationStatements,
                  BasicSymbols

{
  // Note: Existiert in ähnlicher Form in JavaClassExpressions
  // Durch die anderen Nichtterminale darin (z.B. ClassExpression) 
  // würden wir die OCL aber bis zu einem gewissen Grad an Java binden
  // außerdem sind die externals von JavaClassExpressions aufwendiger 
  // zu implementieren, als diese zwei Zeilen zu übernehmen
  TypeCastExpression implements Expression <200> =
    "(" MCType ")" Expression;

  /**
   * ASTTypeIfExpression
   *   Type-safe version of type-cast for variables.
   *     typeif m instanceof Subtype 
   *       then (m known here as Subtype)
   *       else (m here as only Supertype)
   *
   *   Example: 
   *     typeif bm instanceof BidMesssage 
   *     then   bm.auction==copper912 
   *     else   false
   */
  TypeIfExpression implements Expression <100> =
    "typeif" Variable "instanceof" MCType
    "then"   thenExpression:Expression
    "else"   elseExpression:Expression
    ;

  /**
   * IfThenElseExpression defines a logical implies operator.
   *   If the condition is true, thenExpression will be returned,
   *   otherwise the elseExpression will be returned.
   *
   *   Example: a.startTime >= Time.now() implies a.numberOfBids == 0
   */
  // Note: MontiCore's IfStatement from MCCommonStatements cannot be 
  // used here as it would allow to start arbitrary (block) statements
  // (OCL does not have statements) and does not enforce the "else" part
  IfThenElseExpression implements Expression <100> =
    "if"   condition:Expression
    "then" thenExpression:Expression
    "else" elseExpression:Expression
    ;

  /**
   * ASTImpliesExpression defines a logical implies operator.
   *   Example: a.startTime >= Time.now() implies a.numberOfBids == 0
   */
  ImpliesExpression implements Expression <60> =
    left:Expression
    key("implies")
    right:Expression
    ;

  /** 
   * ASTEquivalentExpression defines a logical equals operator.
   *   Example: sa.equals(sb) <=> sa==sb
   */
  EquivalentExpression implements Expression <50> =
    left:Expression operator:"<=>" right:Expression;

  /*=================================================================*/

  /**
   * ASTForAllExpression defines a quantified expression for collections e.g.
   *   "forall x in Y : ...".
   *   @attribute InExpression
   *              List of collection variable declarations, e.g:
   *                "forall a in A: ..."
   *                "forall a in List <..> : ..."
   *                "forall a: ..."
   *   @attribute OCLExpression
   *              The body of forall iteration as an expression.
   */
  scope ForallExpression implements Expression <90> =
    "forall"
    (InExpression || ",")+
    ":"
    Expression
    ;

  /**
   * ASTExistsExpression defines a quantified expression for collections e.g.
   *   "exists x in Y : ...".
   *   @attribute InExpression
   *              List of collection variable declarations, e.g:
   *                "exists a in A: ..."
   *                "exists a in List <..> : ..."
   *                "exists a: ..."
   *   @attribute OCLExpression
   *              The body of exists iteration as an expression.
   */
  scope ExistsExpression implements Expression <90> =
    "exists"
    (InExpression || ",")+
    ":"
    Expression
    ;

  /**
   * ASTOCLAnyExpression selects an element from a non-empty collection e.g.
   *   any x in set or any Auction. The result is underspecified.
   *   @attribute OCLExpression
   *              A collection defined by an expression.
   */
  AnyExpression implements Expression <100> =
    "any" Expression;

  /**
   * ASTOCLLetinExpression are used to define local vars or methods. The defined
   *   vars and methods are visible in the in-expression body.
   *   @attribute declarations
   *              A list of variable or method declarations.
   *   @attribute OCLExpression
   *              An expression where previous declarations are used.
   */
  scope LetinExpression implements Expression <100> =
    "let" (LocalVariableDeclaration || ";")+
    "in" Expression;

  /**
   * ASTOCLIterateExpression is used to iterate collections. It differs from Java5-Iterator.
   *   Example:
   *       iterate{ elem in Auction; int acc=0 : acc = acc+elem.numberOfBids }.
   *   @attribute iterationDeclarator
   *              The elements of a collection that will be iterated as an
   *              OCLCollectionVarDeclaration.
   *   @attribute initDeclarator
   *              Definiton of a accumulation variable as an LocalVariableDeclaration.
   *   @attribute accumulatorName
   *              Name of the accumulation assignment variable.
   *   @attribute accumulatorValue
   *              Right hand of the accumulation as an expression.
   */
  scope IterateExpression implements Expression <100> =
    "iterate" "{"
    iteration:InExpression ";"
    init:LocalVariableDeclaration ":"
    Name "=" value:Expression
    "}";

  /**
   * ASTInExpression defines a collection like "int x in y" or "Auction a" as
   *   shortform of "Auction a in Auction.allInstances").
   */
  InExpression
    = MCType  (Variable || ",")+
    | MCType? (Variable || ",")+ ("in" Expression)
    ;

  /*=================================================================*/

  ParenthizedExpression implements Expression <400> =
    "(" Expression ")"
    ("." qualification:OCLPrimary)?;

  /**
   * ASTOCLPrimary defines primaries of OCL.
   */
  interface OCLPrimary extends Expression <10>;

  /**
   * ASTOCLQualifiedPrimary represents qualified identifier.
   *   @attribute MCQualifiedName
   *              List of names of qualified identifier.
   *   @attribute postfixQualification
   *              Optional argument-, array- or atpre, **-qualifcation.
   *   @attribute OCLQualifiedPrimary
   *              Optional recursive linkage of qualified primary.
   *
   *   example: name.name.name(argument).nextQualifiedPrimary
   *            name.name[expr]
   *            name**
   *            name@pre
   */
  OCLQualifiedPrimary implements OCLPrimary <500> =
    MCQualifiedName
    postfix:OCLQualification?
    ("." OCLQualifiedPrimary)?
    ;

  /**
   * ASTOCLQualification defines qualification postfixes of a qualified
   *   primary. A qualification is one of the three kinds:
   *       - x[0] (ArrayQualification)
   *       - x(y) (ArgumentQualification)
   *       - x**  (TransitiveQualification)
   *       - x@pre (AtPreQualification)
   */
  interface OCLQualification;

  OCLArrayQualification implements OCLQualification =
    ("[" arguments:Expression "]")+;

  OCLArgumentQualification implements OCLQualification =
    "(" (Expression || "," )* ")";

  /**
   * ASTOCLAtPreQualification
   *   Value of the expression in the precondition
   *   Example: post: messageList == messageList@pre.add(m)
   */
  OCLAtPreQualification implements OCLQualification =
    atpre:["@pre"];

  /**
   * ASTOCLTransitiveQualification
   *   Transitive closure of an association. The operator ** is 
   *   only directly applied to a reflexive association. It 
   *   cannot be applied on chains of associations of the form (a.b.c)**
   *   The transitive closure of an association is also calculated if the
   *   association’s source and target are not identical or even if they 
   *   are not subclasses of each other. In that case, the transitive 
   *   closure is identical to the initial association.
   *   Example: this.clique = this.friend**
   */
  OCLTransitiveQualification implements OCLQualification =
    transitive:["**"];
}
