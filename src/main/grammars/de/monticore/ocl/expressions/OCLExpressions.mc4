/* (c) https://github.com/MontiCore/monticore */
package de.monticore.ocl.expressions;

/* Alpha-version: This is intended to become a MontiCore stable grammar. */

import de.monticore.expressions.*;
import de.monticore.types.*;
import de.monticore.statements.*;
import de.monticore.symbols.*;

/**
 * This grammar defines a expressions typical to UMLs OCL
 */
component grammar OCLExpressions
          extends ExpressionsBasis,
                  MCBasicTypes,
                  BasicSymbols

{
  /**
   * ASTTypeCastExpression casts an expression to a given type
   *   @attribute MCType
   *              type to cast the expression to
   *   @attribute Expression
   *              the expression that should be casted
   */
  TypeCastExpression implements Expression <200> =
    "(" MCType ")" Expression;

  /**
   * ASTOCLVariableDeclaration defines a variable
   *   @attribute MCType
   *              type of the variable
   *   @attribute Name
   *              name of the variable
   *   @attribute Expression
   *              initial value of the variable
   */
  OCLVariableDeclaration implements Variable =
    MCType? Name (dim:"[" "]")* ("=" Expression)?;

  /**
   * ASTTypeIfExpression
   *   Type-safe version of type-cast for variables.
   *     typeif m instanceof Subtype 
   *       then (m known here as Subtype)
   *       else (m here as only Supertype)
   *
   *  @attribute Name@Variable
   *             Name of a variable of which the type should be checked
   *  @attribute MCType
   *             The type to which the variable should be compared
   *  @attribute thenExpression
   *             resulting expression in which the variable can be used with
   *             the type defined by MCType (if the type check returns true)
   *  @attribute elseExpression
   *             resulting expression which will be evaluated if the variable
   *             is not of the type defined by MCType
   *
   *   Example: 
   *     typeif bm instanceof BidMesssage 
   *     then   bm.auction==copper912 
   *     else   false
   */
  TypeIfExpression implements Expression <100> =
    "typeif" Name@Variable "instanceof" MCType
    "then"   thenExpression:Expression
    "else"   elseExpression:Expression
    ;

  /**
   * IfThenElseExpression defines a case distinction operator.
   *   If the condition is true, thenExpression will be returned,
   *   otherwise the elseExpression will be returned.
   *
   *   @attribute condition
   *              the condition to be evaluated
   *   @attribute thenExpression
   *              the expression to return if the condition is true
   *   @attribute elseExpression
   *              the expression to return if the condition is false
   */
  IfThenElseExpression implements Expression <100> =
    "if"   condition:Expression
    "then" thenExpression:Expression
    "else" elseExpression:Expression
    ;

  /**
   * ASTImpliesExpression defines a logical implies operator.
   *   Example: a.startTime >= Time.now() implies a.numberOfBids == 0
   *
   *   Note that it may be useful to use the "nokeyword"-keyword when
   *   using this grammar in order to mark "implies" as temporary
   */
  ImpliesExpression implements Expression <60> =
    left:Expression
    "implies"
    right:Expression
    ;

  /** 
   * ASTEquivalentExpression defines a logical equals operator.
   *   Example: sa.equals(sb) <=> sa==sb
   */
  EquivalentExpression implements Expression <50> =
    left:Expression operator:"<=>" right:Expression;

  /*=================================================================*/

  /**
   * ASTForAllExpression defines a quantified expression for collections e.g.
   *   "forall x in Y : ...".
   *   @attribute InDeclaration
   *              List of collection variable declarations, e.g:
   *                "forall a in A: ..."
   *                "forall a in List <..> : ..."
   *                "forall a: ..."
   *   @attribute OCLExpression
   *              The body of forall iteration as an expression.
   */
  scope ForallExpression implements Expression <90> =
    "forall"
    (InDeclaration || ",")+
    ":"
    Expression
    ;

  /**
   * ASTExistsExpression defines a quantified expression for collections e.g.
   *   "exists x in Y : ...".
   *   @attribute InDeclaration
   *              List of collection variable declarations, e.g:
   *                "exists a in A: ..."
   *                "exists a in List <..> : ..."
   *                "exists a: ..."
   *   @attribute OCLExpression
   *              The body of exists iteration as an expression.
   */
  scope ExistsExpression implements Expression <90> =
    "exists"
    (InDeclaration || ",")+
    ":"
    Expression
    ;

  /**
   * ASTOCLAnyExpression selects an element from a non-empty collection e.g.
   *   any x in set or any Auction. The result is underspecified.
   *   @attribute OCLExpression
   *              A collection defined by an expression.
   */
  AnyExpression implements Expression <100> =
    "any" Expression;

  /**
   * ASTOCLLetinExpression are used to define local vars or methods. The defined
   *   vars and methods are visible in the in-expression body.
   *   @attribute letDeclaration
   *              A list of variable declarations.
   *   @attribute expression
   *              An expression where previous declarations are used.
   */
  scope LetinExpression implements Expression <100> =
    "let" (OCLVariableDeclaration || ";")+
    "in" Expression ;

  /**
   * ASTOCLIterateExpression is used to iterate collections. It differs from
   * Java5-Iterator.
   *   Example:
   *       iterate{ elem in Auction; int acc=0 : acc = acc+elem.numberOfBids }.
   *   @attribute iterationDeclarator
   *              The elements of a collection that will be iterated as an
   *              OCLCollectionVarDeclaration.
   *   @attribute initDeclarator
   *              Definiton of a accumulation variable as an
   *              OCLVariableDeclaration.
   *   @attribute accumulatorName
   *              Name of the accumulation assignment variable.
   *   @attribute accumulatorValue
   *              Right hand of the accumulation as an expression.
   */
  scope IterateExpression implements Expression <100> =
    "iterate" "{"
    iteration:InDeclaration ";"
    init:OCLVariableDeclaration ":"
    Name@Variable "=" value:Expression
    "}";

  /**
   * ASTInDeclaration defines a collection like "int x in y" or "Auction a" as
   *   shortform of "Auction a in Auction.allInstances").
   */
  InDeclaration
    = MCType  (Variable || ",")+
    | MCType? (Variable || ",")+ ("in" Expression)
    ;

  /*=================================================================*/

  ParenthizedExpression implements Expression <400> =
    "(" Expression ")"
    ("." qualification:OCLQualifiedPrimary)?;

  /**
   * ASTOCLQualifiedPrimary represents qualified identifier.
   *   @attribute MCQualifiedName
   *              List of names of qualified identifier.
   *   @attribute postfixQualification
   *              Optional argument-, array- or atpre, **-qualifcation.
   *   @attribute OCLQualifiedPrimary
   *              Optional recursive linkage of qualified primary.
   *
   *   example: name.name.name(argument).nextQualifiedPrimary
   *            name.name[expr]
   *            name**
   *            name@pre
   */
  OCLQualifiedPrimary implements Expression <500> =
    MCQualifiedName
    postfix:OCLQualification?
    ("." OCLQualifiedPrimary)?
    ;

  /**
   * ASTOCLQualification defines qualification postfixes of a qualified
   *   primary. A qualification is one of the three kinds:
   *       - x[0] (ArrayQualification)
   *       - x(y) (ArgumentQualification)
   *       - x**  (TransitiveQualification)
   *       - x@pre (AtPreQualification)
   */
  interface OCLQualification;

  OCLArrayQualification implements OCLQualification =
    ("[" arguments:Expression "]")+;

  OCLArgumentQualification implements OCLQualification =
    "(" (Expression || "," )* ")";

  /**
   * ASTOCLAtPreQualification
   *   Value of the expression in the precondition
   *   Example: post: messageList == messageList@pre.add(m)
   */
  OCLAtPreQualification implements OCLQualification =
    atpre:["@pre"];

  /**
   * ASTOCLTransitiveQualification
   *   Transitive closure of an association. The operator ** is 
   *   only directly applied to a reflexive association. It 
   *   cannot be applied on chains of associations of the form (a.b.c)**
   *   The transitive closure of an association is also calculated if the
   *   associationâ€™s source and target are not identical or even if they 
   *   are not subclasses of each other. In that case, the transitive 
   *   closure is identical to the initial association.
   *   Example: this.clique = this.friend**
   */
  OCLTransitiveQualification implements OCLQualification =
    transitive:["**"];
}
